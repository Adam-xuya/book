<!-- Old headings. Do not remove or links may break. -->

<a id="managing-growing-projects-with-packages-crates-and-modules"></a>

# 包、Crate 和模块

当你编写大型程序时，组织你的代码将变得越来越重要。通过将相关功能分组并分离具有不同特性的代码，你可以明确在哪里找到实现特定功能的代码以及在哪里更改功能的工作方式。

到目前为止，我们编写的程序都在一个文件的一个模块中。随着项目的增长，你应该通过将代码拆分为多个模块然后拆分为多个文件来组织代码。一个包可以包含多个二进制 crate 和可选的一个库 crate。随着包的增长，你可以将部分提取到成为外部依赖项的单独 crate 中。本章涵盖了所有这些技术。对于由一组相互关联的包组成的大型项目，这些包一起演进，Cargo 提供了工作空间，我们将在第 14 章的["Cargo 工作空间"][workspaces]<!-- ignore -->中介绍。

我们还将讨论封装实现细节，这让你可以在更高的级别重用代码：一旦你实现了一个操作，其他代码可以通过其公共接口调用你的代码，而无需知道实现如何工作。你编写代码的方式定义了哪些部分是供其他代码使用的公共部分，哪些部分是你保留更改权利的私有实现细节。这是限制你必须记住的细节数量的另一种方法。

一个相关的概念是作用域：编写代码的嵌套上下文具有一组定义为"在作用域内"的名称。在读取、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是指变量、函数、结构体、枚举、模块、常量还是其他项，以及该项的含义。你可以创建作用域并更改哪些名称在作用域内或作用域外。你不能在同一作用域中有两个同名项；有工具可用于解决名称冲突。

Rust 有许多功能允许你管理代码的组织，包括哪些细节是公开的，哪些细节是私有的，以及程序中每个作用域中有哪些名称。这些功能，有时统称为 _模块系统_，包括：

* **包（Packages）**：一个 Cargo 功能，让你可以构建、测试和共享 crate
* **Crate**：一个模块树，它产生一个库或可执行文件
* **模块和 use**：让你控制组织、作用域和路径的隐私
* **路径（Paths）**：命名项（如结构体、函数或模块）的一种方式

在本章中，我们将介绍所有这些功能，讨论它们如何交互，并解释如何使用它们来管理作用域。到最后，你应该对模块系统有扎实的理解，并能够像专业人士一样使用作用域！

[workspaces]: ch14-03-cargo-workspaces.html
