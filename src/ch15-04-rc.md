## `Rc<T>`，引用计数智能指针

在大多数情况下，所有权是明确的：你确切知道哪个变量拥有给定值。但是，在某些情况下，单个值可能有多个所有者。例如，在图数据结构中，多个边可能指向同一节点，该节点在概念上由所有指向它的边拥有。节点不应该被清理，除非它没有任何指向它的边，因此没有所有者。

你必须通过使用 Rust 类型 `Rc<T>` 显式启用多个所有权，它是 _引用计数_ 的缩写。`Rc<T>` 类型跟踪对值的引用数量，以确定值是否仍在使用。如果对值的引用为零，可以清理该值，而不会使任何引用无效。

将 `Rc<T>` 想象为家庭房间中的电视。当一个人进入观看电视时，他们打开它。其他人可以进入房间并观看电视。当最后一个人离开房间时，他们关闭电视，因为它不再被使用。如果有人在他人在观看时关闭电视，其余观看者会感到不安！

当我们在堆上分配一些数据供程序多个部分读取，并且无法在编译时确定哪个部分将最后完成使用数据时，我们使用 `Rc<T>` 类型。如果我们知道哪个部分将最后完成，我们可以只使该部分成为数据的所有者，并且在编译时强制执行的正常所有权规则将生效。

注意，`Rc<T>` 仅用于单线程场景。当我们在第 16 章讨论并发时，我们将介绍如何在多线程程序中进行引用计数。

<!-- Old headings. Do not remove or links may break. -->

<a id="using-rct-to-share-data"></a>

### 共享数据

让我们回到代码清单 15-5 中的 cons 列表示例。回想一下，我们使用 `Box<T>` 定义了它。这次，我们将创建两个列表，它们都共享第三个列表的所有权。从概念上讲，这看起来类似于 Figure 15-3。

<img alt="A linked list with the label 'a' pointing to three elements. The first element contains the integer 5 and points to the second element. The second element contains the integer 10 and points to the third element. The third element contains the value 'Nil' that signifies the end of the list; it does not point anywhere. A linked list with the label 'b' points to an element that contains the integer 3 and points to the first element of list 'a'. A linked list with the label 'c' points to an element that contains the integer 4 and also points to the first element of list 'a' so that the tails of lists 'b' and 'c' are both list 'a'." src="img/trpl15-03.svg" class="center" />

<span class="caption">Figure 15-3: 两个列表 `b` 和 `c`，共享第三个列表 `a` 的所有权</span>

我们将创建包含 `5` 然后 `10` 的列表 `a`。然后，我们将创建另外两个列表：以 `3` 开头的 `b` 和以 `4` 开头的 `c`。然后，`b` 和 `c` 列表都将继续到包含 `5` 和 `10` 的第一个 `a` 列表。换句话说，两个列表将共享包含 `5` 和 `10` 的第一个列表。

尝试使用我们使用 `Box<T>` 定义的 `List` 实现此场景将不起作用，如代码清单 15-17 所示。

<Listing number="15-17" file-name="src/main.rs" caption="演示不允许有两个使用 `Box<T>` 的列表尝试共享第三个列表的所有权">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

</Listing>

当我们编译此代码时，我们得到此错误：

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

`Cons` 变体拥有它们保存的数据，所以当我们创建 `b` 列表时，`a` 被移动到 `b` 中，`b` 拥有 `a`。然后，当我们在创建 `c` 时尝试再次使用 `a` 时，我们不被允许，因为 `a` 已被移动。

我们可以更改 `Cons` 的定义以保存引用而不是，但然后我们将不得不指定生命周期参数。通过指定生命周期参数，我们将指定列表中的每个元素将至少与整个列表一样长。这是代码清单 15-17 中的元素和列表的情况，但不是每个场景中的情况。

相反，我们将更改 `List` 的定义以使用 `Rc<T>` 代替 `Box<T>`，如代码清单 15-18 所示。每个 `Cons` 变体现在将保存一个值和一个指向 `List` 的 `Rc<T>`。当我们创建 `b` 时，我们不是获取 `a` 的所有权，而是克隆 `a` 持有的 `Rc<List>`，从而将引用数量从一个增加到两个，并让 `a` 和 `b` 共享该 `Rc<List>` 中数据的所有权。我们还在创建 `c` 时克隆 `a`，将引用数量从两个增加到三个。每次我们调用 `Rc::clone`，`Rc<List>` 内数据的引用计数将增加，除非对它的引用为零，否则数据不会被清理。

<Listing number="15-18" file-name="src/main.rs" caption="使用 `Rc<T>` 的 `List` 定义">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

</Listing>

我们需要添加一个 `use` 语句以将 `Rc<T>` 引入作用域，因为它不在 prelude 中。在 `main` 中，我们创建保存 `5` 和 `10` 的列表，并将其存储在 `a` 中的新 `Rc<List>` 中。然后，当我们创建 `b` 和 `c` 时，我们调用 `Rc::clone` 函数并将 `a` 中的 `Rc<List>` 的引用作为参数传递。

我们本可以调用 `a.clone()` 而不是 `Rc::clone(&a)`，但 Rust 的约定是在这种情况下使用 `Rc::clone`。`Rc::clone` 的实现不像大多数类型的 `clone` 实现那样对所有数据进行深拷贝。对 `Rc::clone` 的调用只增加引用计数，这不需要太多时间。数据的深拷贝可能需要很多时间。通过使用 `Rc::clone` 进行引用计数，我们可以在视觉上区分深拷贝类型的克隆和增加引用计数的克隆类型。在代码中查找性能问题时，我们只需要考虑深拷贝克隆，可以忽略对 `Rc::clone` 的调用。

<!-- Old headings. Do not remove or links may break. -->

<a id="cloning-an-rct-increases-the-reference-count"></a>

### 克隆以增加引用计数

让我们更改代码清单 15-18 中的工作示例，以便我们可以看到引用计数在我们创建和丢弃对 `a` 中 `Rc<List>` 的引用时如何变化。

在代码清单 15-19 中，我们将更改 `main`，使其在列表 `c` 周围有一个内部作用域；然后，我们可以看到当 `c` 超出作用域时引用计数如何变化。

<Listing number="15-19" file-name="src/main.rs" caption="打印引用计数">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

</Listing>

在程序中引用计数改变的每个点，我们打印引用计数，我们通过调用 `Rc::strong_count` 函数获得。此函数被命名为 `strong_count` 而不是 `count`，因为 `Rc<T>` 类型也有 `weak_count`；我们将在["使用 `Weak<T>` 防止引用循环"][preventing-ref-cycles]<!-- ignore -->中看到 `weak_count` 的用途。

此代码打印以下内容：

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

我们可以看到 `a` 中的 `Rc<List>` 的初始引用计数为 1；然后，每次我们调用 `clone`，计数增加 1。当 `c` 超出作用域时，计数减少 1。我们不必调用函数来减少引用计数，就像我们必须调用 `Rc::clone` 来增加引用计数一样：`Drop` trait 的实现会在 `Rc<T>` 值超出作用域时自动减少引用计数。

我们在本例中看不到的是，当 `b` 然后在 `main` 结束时 `a` 超出作用域时，计数为 0，`Rc<List>` 被完全清理。使用 `Rc<T>` 允许单个值具有多个所有者，并且计数确保只要任何所有者仍然存在，值就保持有效。

通过不可变引用，`Rc<T>` 允许你在程序的多个部分之间共享数据以仅读取。如果 `Rc<T>` 也允许你有多个可变引用，你可能违反第 4 章中讨论的借用规则之一：对同一位置的多个可变借用可能导致数据竞争和不一致。但能够改变数据非常有用！在下一节中，我们将讨论内部可变性模式和 `RefCell<T>` 类型，你可以将其与 `Rc<T>` 结合使用以处理此不可变性限制。

[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
