# 智能指针

指针是包含内存中地址的变量的通用概念。此地址引用或"指向"其他一些数据。Rust 中最常见的指针类型是引用，你在第 4 章中学到了它。引用由 `&` 符号表示，并借用它们指向的值。除了引用数据之外，它们没有任何特殊功能，并且它们没有开销。

另一方面，_智能指针_ 是像指针一样行为但也具有额外元数据和功能的数据结构。智能指针的概念不是 Rust 独有的：智能指针起源于 C++ 并存在于其他语言中。Rust 在标准库中定义了各种智能指针，提供超出引用提供的功能。为了探索通用概念，我们将查看几个不同的智能指针示例，包括一个 _引用计数_ 智能指针类型。此指针使你可以通过跟踪所有者数量并在没有所有者剩余时清理数据来允许数据具有多个所有者。

在 Rust 中，凭借其所有权和借用的概念，引用和智能指针之间存在额外差异：虽然引用只借用数据，但在许多情况下，智能指针 _拥有_ 它们指向的数据。

智能指针通常使用结构体实现。与普通结构体不同，智能指针实现 `Deref` 和 `Drop` trait。`Deref` trait 允许智能指针结构体的实例表现得像引用，以便你可以编写代码来处理引用或智能指针。`Drop` trait 允许你自定义在智能指针实例超出作用域时运行的代码。在本章中，我们将讨论这两个 trait 并演示为什么它们对智能指针很重要。

鉴于智能指针模式是 Rust 中经常使用的通用设计模式，本章不会涵盖每个现有的智能指针。许多库都有自己的智能指针，你甚至可以编写自己的智能指针。我们将涵盖标准库中最常见的智能指针：

- `Box<T>`，用于在堆上分配值
- `Rc<T>`，一种引用计数类型，可实现多个所有权
- `Ref<T>` 和 `RefMut<T>`，通过 `RefCell<T>` 访问，这是一种在运行时而不是编译时强制执行借用规则的类型

此外，我们将涵盖 _内部可变性_ 模式，其中不可变类型公开用于改变内部值的 API。我们还将讨论引用循环：它们如何泄漏内存以及如何防止它们。

让我们开始吧！
