## 什么是所有权？

_所有权_是一组管理 Rust 程序如何管理内存的规则。所有程序在运行时都必须管理它们使用计算机内存的方式。一些语言有垃圾收集器，在程序运行时定期查找不再使用的内存；在其他语言中，程序员必须显式分配和释放内存。Rust 使用第三种方法：内存通过所有权系统进行管理，该系统有一组编译器检查的规则。如果违反了任何规则，程序将无法编译。所有权的功能都不会在程序运行时减慢程序速度。

因为所有权对许多程序员来说是一个新概念，确实需要一些时间来适应。好消息是，您对 Rust 和所有权系统规则的经验越多，您就越容易自然地开发安全高效的代码。坚持下去！

当您理解所有权时，您将有一个坚实的基础来理解使 Rust 独特的功能。在本章中，您将通过一些专注于非常常见的数据结构的示例来学习所有权：字符串。

> ### 栈和堆
>
> 许多编程语言不需要您经常考虑栈和堆。但在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上会影响语言的行为以及您必须做出某些决定的原因。所有权的部分将在本章后面根据栈和堆进行描述，所以这里是一个简短的准备说明。
>
> 栈和堆都是代码在运行时可用于使用的内存部分，但它们以不同的方式构造。栈按接收值的顺序存储值，并按相反的顺序删除值。这被称为_后进先出（LIFO）_。想象一堆盘子：当您添加更多盘子时，您将它们放在堆的顶部，当您需要一个盘子时，您从顶部取一个。从中间或底部添加或删除盘子不会很好地工作！添加数据称为_推入栈_，删除数据称为_弹出栈_。存储在栈上的所有数据都必须具有已知的固定大小。在编译时大小未知或大小可能发生变化的数据必须存储在堆上。
>
> 堆的组织性较差：当您将数据放在堆上时，您请求一定数量的空间。内存分配器在堆中找到一个足够大的空位，将其标记为正在使用，并返回一个_指针_，即该位置的地址。此过程称为_在堆上分配_，有时简称为_分配_（将值推入栈不被视为分配）。因为指向堆的指针是已知的固定大小，您可以将指针存储在栈上，但当您想要实际数据时，必须跟随指针。想象坐在餐厅里。当您进入时，您说明您组中的人数，主人找到一张适合所有人的空桌并带您到那里。如果您组中的某人来晚了，他们可以询问您坐在哪里来找到您。
>
> 推入栈比在堆上分配快，因为分配器永远不必搜索存储新数据的位置；该位置总是在栈的顶部。相比之下，在堆上分配空间需要更多工作，因为分配器必须首先找到足够大的空间来保存数据，然后执行簿记以为下一次分配做准备。
>
> 访问堆中的数据通常比访问栈中的数据慢，因为您必须跟随指针才能到达那里。如果处理器在内存中跳转较少，当代处理器会更快。继续这个类比，考虑餐厅中的服务员从许多桌子接收订单。在移动到下一张桌子之前在一张桌子上获取所有订单是最有效的。从桌子 A 取一个订单，然后从桌子 B 取一个订单，然后再次从 A 取一个，然后再次从 B 取一个，这将是一个慢得多的过程。同样，如果处理器处理与其他数据接近的数据（就像在栈上一样）而不是更远的数据（就像在堆上可能的情况），处理器通常可以更好地完成其工作。
>
> 当您的代码调用函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被推入栈。当函数结束时，这些值被弹出栈。
>
> 跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上重复数据的数量，以及清理堆上未使用的数据，以便您不会耗尽空间，这些都是所有权解决的问题。一旦您理解了所有权，您就不需要经常考虑栈和堆。但知道所有权的主要目的是管理堆数据可以帮助解释它为什么以这种方式工作。

### 所有权规则

首先，让我们看一下所有权规则。在我们通过说明它们的示例时，请记住这些规则：

- Rust 中的每个值都有一个_所有者_。
- 一次只能有一个所有者。
- 当所有者超出作用域时，该值将被丢弃。

### 变量作用域

既然我们已经完成了基本的 Rust 语法，我们不会在示例中包含所有 `fn main() {` 代码，所以如果您正在跟随，请确保手动将以下示例放在 `main` 函数内部。因此，我们的示例会更加简洁，让我们专注于实际细节而不是样板代码。

作为所有权的第一个示例，我们将查看某些变量的作用域。_作用域_是程序中项目有效的范围。以以下变量为例：

```rust
let s = "hello";
```

变量 `s` 引用字符串字面量，其中字符串的值硬编码到我们程序的文本中。变量从声明它的点开始有效，直到当前作用域结束。清单 4-1 显示了一个程序，带有注释注释变量 `s` 将有效的位置。

<Listing number="4-1" caption="变量及其有效的作用域">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

</Listing>

换句话说，这里有两个重要的时间点：

- 当 `s` 进入作用域时，它是有效的。
- 它保持有效直到它超出作用域。

此时，作用域和变量何时有效之间的关系与其他编程语言中的类似。现在，我们将通过引入 `String` 类型在此理解的基础上构建。

### `String` 类型

为了说明所有权规则，我们需要一个比我们在第 3 章的["数据类型"][data-types]<!-- ignore -->部分中涵盖的类型更复杂的数据类型。之前涵盖的类型是已知大小的，可以存储在栈上，并在其作用域结束时从栈中弹出，并且可以快速且简单地复制以创建新的独立实例，如果代码的另一部分需要在不同作用域中使用相同的值。但我们想查看存储在堆上的数据，并探索 Rust 如何知道何时清理该数据，而 `String` 类型是一个很好的示例。

我们将专注于 `String` 与所有权相关的部分。这些方面也适用于其他复杂数据类型，无论它们是由标准库提供还是由您创建的。我们将在[第 8 章][ch8]<!-- ignore -->中讨论 `String` 的非所有权方面。

我们已经看到字符串字面量，其中字符串值硬编码到我们的程序中。字符串字面量很方便，但它们不适合我们可能想要使用文本的每种情况。一个原因是它们是不可变的。另一个原因是，并非每个字符串值都可以在我们编写代码时知道：例如，如果我们想要获取用户输入并存储它怎么办？正是针对这些情况，Rust 有 `String` 类型。此类型管理分配在堆上的数据，因此能够存储我们在编译时不知道的文本量。您可以使用 `from` 函数从字符串字面量创建 `String`，如下所示：

```rust
let s = String::from("hello");
```

双冒号 `::` 运算符允许我们在 `String` 类型下命名空间化这个特定的 `from` 函数，而不是使用某种名称，如 `string_from`。我们将在第 5 章的["方法"][methods]<!--
ignore -->部分以及在第 7 章的["用于引用模块树中项目的路径"][paths-module-tree]<!-- ignore -->中讨论模块命名空间时更详细地讨论此语法。

这种字符串_可以_被改变：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

那么，这里有什么区别？为什么 `String` 可以被改变，但字面量不能？区别在于这两种类型如何处理内存。

### 内存和分配

对于字符串字面量，我们在编译时知道内容，因此文本直接硬编码到最终可执行文件中。这就是为什么字符串字面量快速高效。但这些属性仅来自字符串字面量的不可变性。不幸的是，我们不能为每个在编译时大小未知且大小可能在程序运行时发生变化的文本片段将内存块放入二进制文件中。

对于 `String` 类型，为了支持可变、可增长的文本片段，我们需要在堆上分配一定数量的内存，在编译时未知，以保存内容。这意味着：

- 必须在运行时从内存分配器请求内存。
- 当我们完成使用 `String` 时，我们需要一种方法将此内存返回给分配器。

第一部分由我们完成：当我们调用 `String::from` 时，其实现请求它需要的内存。这在编程语言中几乎是通用的。

但是，第二部分是不同的。在具有_垃圾收集器（GC）_的语言中，GC 跟踪并清理不再使用的内存，我们不需要考虑它。在大多数没有 GC 的语言中，我们有责任识别何时不再使用内存并调用代码显式释放它，就像我们请求它一样。正确地做到这一点历来是一个困难的编程问题。如果我们忘记了，我们会浪费内存。如果我们做得太早，我们将有一个无效的变量。如果我们做两次，这也是一个错误。我们需要恰好将一个 `allocate` 与恰好一个 `free` 配对。

Rust 采用不同的路径：一旦拥有它的变量超出作用域，内存就会自动返回。这是我们在清单 4-1 中使用 `String` 而不是字符串字面量的作用域示例版本：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

有一个自然的点，我们可以将 `String` 需要的内存返回给分配器：当 `s` 超出作用域时。当变量超出作用域时，Rust 为我们调用一个特殊函数。此函数称为 [`drop`][drop]<!-- ignore -->，这是 `String` 的作者可以放置返回内存的代码的地方。Rust 在右花括号处自动调用 `drop`。

> 注意：在 C++ 中，在项目生命周期结束时释放资源的这种模式有时称为_资源获取即初始化（RAII）_。如果您使用过 RAII 模式，Rust 中的 `drop` 函数对您来说会很熟悉。

这种模式对 Rust 代码的编写方式有深远的影响。现在看起来可能很简单，但在我们想要让多个变量使用我们在堆上分配的数据的更复杂情况下，代码的行为可能会出乎意料。现在让我们探索其中一些情况。

<!-- Old headings. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-move"></a>

#### 变量和数据交互：移动

多个变量可以在 Rust 中以不同方式与相同数据交互。清单 4-2 显示了一个使用整数的示例。

<Listing number="4-2" caption="将变量 `x` 的整数值赋值给 `y`">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

</Listing>

我们可能可以猜到这是做什么的："将值 `5` 绑定到 `x`；然后，复制 `x` 中的值并将其绑定到 `y`。"我们现在有两个变量 `x` 和 `y`，都等于 `5`。这确实是正在发生的事情，因为整数是具有已知固定大小的简单值，这两个 `5` 值被推入栈。

现在让我们看一下 `String` 版本：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```

这看起来非常相似，所以我们可能假设它的工作方式会相同：也就是说，第二行会复制 `s1` 中的值并将其绑定到 `s2`。但这并不是完全发生的事情。

查看图 4-1 以了解 `String` 在幕后发生了什么。`String` 由三部分组成，如左侧所示：指向保存字符串内容的内存的指针、长度和容量。这组数据存储在栈上。右侧是保存内容的堆内存。

<img alt="两个表：第一个表包含栈上 s1 的表示，由长度（5）、容量（5）和指向第二个表中第一个值的指针组成。第二个表包含堆上字符串数据的表示，逐字节。" src="img/trpl04-01.svg" class="center"
style="width: 50%;" />

<span class="caption">图 4-1：绑定到 `s1` 的 `String` 在内存中保存值 `"hello"` 的表示</span>

长度是 `String` 的内容当前使用的内存量（以字节为单位）。容量是 `String` 从分配器接收的总内存量（以字节为单位）。长度和容量之间的差异很重要，但在此上下文中不重要，所以现在忽略容量是可以的。

当我们将 `s1` 赋值给 `s2` 时，会复制 `String` 数据，这意味着我们复制指针、长度和栈上的容量。我们不复制指针指向的堆上的数据。换句话说，内存中的数据表示看起来像图 4-2。

<img alt="三个表：表 s1 和 s2 分别表示栈上的那些字符串，都指向堆上的相同字符串数据。" src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-2：变量 `s2` 在内存中的表示，它复制了 `s1` 的指针、长度和容量</span>

表示_不_看起来像图 4-3，如果 Rust 也复制堆数据，这将是内存的样子。如果 Rust 这样做，如果堆上的数据很大，操作 `s2 = s1` 在运行时性能方面可能非常昂贵。

<img alt="四个表：两个表表示 s1 和 s2 的栈数据，每个都指向堆上字符串数据的自己的副本。" src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-3：如果 Rust 也复制堆数据，`s2 = s1` 可能做的另一种可能性</span>

早些时候，我们说过当变量超出作用域时，Rust 会自动调用 `drop` 函数并清理该变量的堆内存。但是图 4-2 显示两个数据指针都指向同一位置。这是一个问题：当 `s2` 和 `s1` 超出作用域时，它们都会尝试释放相同的内存。这被称为_双重释放_错误，是我们之前提到的内存安全错误之一。释放内存两次可能导致内存损坏，这可能潜在地导致安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 行之后，Rust 认为 `s1` 不再有效。因此，当 `s1` 超出作用域时，Rust 不需要释放任何东西。看看在创建 `s2` 后尝试使用 `s1` 时会发生什么；它不会工作：

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

您会得到这样的错误，因为 Rust 阻止您使用无效的引用：

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

如果您在使用其他语言时听说过_浅拷贝_和_深拷贝_这两个术语，复制指针、长度和容量而不复制数据的概念可能听起来像是进行浅拷贝。但由于 Rust 也使第一个变量无效，而不是被称为浅拷贝，它被称为_移动_。在此示例中，我们会说 `s1` 被_移动_到 `s2`。所以，实际发生的事情如图 4-4 所示。

<img alt="三个表：表 s1 和 s2 分别表示栈上的那些字符串，都指向堆上的相同字符串数据。表 s1 被灰掉，因为 s1 不再有效；只有 s2 可以用来访问堆数据。" src="img/trpl04-04.svg" class="center" style="width:
50%;" />

<span class="caption">图 4-4：`s1` 失效后内存中的表示</span>

这解决了我们的问题！只有 `s2` 有效，当它超出作用域时，它单独将释放内存，我们就完成了。

此外，这里有一个隐含的设计选择：Rust 永远不会自动创建数据的"深"副本。因此，任何_自动_复制都可以假设在运行时性能方面是廉价的。

#### 作用域和赋值

这对作用域、所有权和通过 `drop` 函数释放内存之间的关系也是相反的。当您将全新值赋值给现有变量时，Rust 将立即调用 `drop` 并释放原始值的内存。例如，考虑此代码：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04b-replacement-drop/src/main.rs:here}}
```

我们最初声明一个变量 `s` 并将其绑定到值为 `"hello"` 的 `String`。然后，我们立即创建一个值为 `"ahoy"` 的新 `String` 并将其赋值给 `s`。此时，没有任何东西引用堆上的原始值。图 4-5 说明了现在的栈和堆数据：

<img alt="一个表表示栈上的字符串值，指向堆上的第二段字符串数据（ahoy），原始字符串数据（hello）被灰掉，因为它无法再访问。" src="img/trpl04-05.svg" class="center" style="width: 50%;" />

<span class="caption">图 4-5：初始值完全替换后内存中的表示</span>

因此，原始字符串立即超出作用域。Rust 将在其上运行 `drop` 函数，其内存将立即释放。当我们在最后打印值时，它将是 `"ahoy, world!"`。

<!-- Old headings. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-clone"></a>

#### 变量和数据交互：克隆

如果我们_确实_想要深度复制 `String` 的堆数据，而不仅仅是栈数据，我们可以使用一个称为 `clone` 的常见方法。我们将在第 5 章讨论方法语法，但因为方法是许多编程语言中的常见功能，您可能以前见过它们。

以下是 `clone` 方法在实际中的示例：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

这工作得很好，并显式产生图 4-3 中显示的行为，其中堆数据_确实_被复制。

当您看到对 `clone` 的调用时，您知道正在执行一些任意代码，并且该代码可能很昂贵。这是正在发生不同事情的视觉指示器。

#### 仅栈数据：复制

还有另一个我们尚未讨论的细节。这段使用整数的代码——其中一部分在清单 4-2 中显示——工作正常且有效：

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

但这段代码似乎与我们刚刚学到的相矛盾：我们没有调用 `clone`，但 `x` 仍然有效，没有被移动到 `y`。

原因是像整数这样在编译时具有已知大小的类型完全存储在栈上，因此实际值的副本可以快速制作。这意味着我们没有理由在创建变量 `y` 后阻止 `x` 有效。换句话说，这里深拷贝和浅拷贝之间没有区别，所以调用 `clone` 不会做任何与通常的浅拷贝不同的事情，我们可以省略它。

Rust 有一个称为 `Copy` trait 的特殊注释，我们可以将其放在存储在栈上的类型上，就像整数一样（我们将在[第 10 章][traits]<!-- ignore -->中更多地讨论 trait）。如果类型实现了 `Copy` trait，使用它的变量不会移动，而是被简单地复制，使它们在赋值给另一个变量后仍然有效。

如果类型或其任何部分实现了 `Drop` trait，Rust 不会让我们用 `Copy` 注释类型。如果类型需要在值超出作用域时发生某些特殊的事情，并且我们将 `Copy` 注释添加到该类型，我们将得到编译时错误。要了解如何将 `Copy` 注释添加到您的类型以实现 trait，请参见附录 C 中的["可派生 Trait"][derivable-traits]<!-- ignore -->。

那么，哪些类型实现了 `Copy` trait？您可以查看给定类型的文档以确定，但作为一般规则，任何简单标量值组都可以实现 `Copy`，而任何需要分配或某种形式的资源都不能实现 `Copy`。以下是一些实现 `Copy` 的类型：

- 所有整数类型，例如 `u32`。
- 布尔类型 `bool`，值为 `true` 和 `false`。
- 所有浮点类型，例如 `f64`。
- 字符类型 `char`。
- 元组，如果它们只包含也实现 `Copy` 的类型。例如，`(i32, i32)` 实现 `Copy`，但 `(i32, String)` 不实现。

### 所有权和函数

将值传递给函数的机制与将值赋值给变量时类似。将变量传递给函数会移动或复制，就像赋值一样。清单 4-3 有一个示例，带有一些注释显示变量进入和超出作用域的位置。

<Listing number="4-3" file-name="src/main.rs" caption="带有所有权和作用域注释的函数">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

</Listing>

如果我们在调用 `takes_ownership` 后尝试使用 `s`，Rust 会抛出编译时错误。这些静态检查保护我们免受错误。尝试添加代码到 `main`，使用 `s` 和 `x` 来查看您可以在哪里使用它们，以及所有权规则在哪里阻止您这样做。

### 返回值和作用域

返回值也可以转移所有权。清单 4-4 显示了一个返回某个值的函数示例，带有与清单 4-3 中类似的注释。

<Listing number="4-4" file-name="src/main.rs" caption="转移返回值的所有权">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

</Listing>

变量的所有权每次都遵循相同的模式：将值赋值给另一个变量会移动它。当包含堆上数据的变量超出作用域时，该值将被 `drop` 清理，除非数据的所有权已移动到另一个变量。

虽然这有效，但每次函数都获取所有权然后返回所有权有点繁琐。如果我们想让函数使用值但不获取所有权怎么办？如果我们想再次使用它，我们传入的任何东西也需要传回，这很烦人，另外还有函数体可能产生的任何数据，我们可能也想返回。

Rust 确实允许我们使用元组返回多个值，如清单 4-5 所示。

<Listing number="4-5" file-name="src/main.rs" caption="返回参数的所有权">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

</Listing>

但对于一个应该是常见的概念来说，这太繁琐了，工作量很大。幸运的是，Rust 有一个功能可以使用值而不转移所有权：引用。

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[methods]: ch05-03-method-syntax.html#methods
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
