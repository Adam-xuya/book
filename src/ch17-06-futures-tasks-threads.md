## 总结：Futures、Tasks 和 Threads

正如我们在[第16章][ch16]<!-- ignore -->中看到的，线程提供了一种并发方法。我们在本章中看到了另一种方法：使用 async 与 futures 和 streams。如果你想知道何时选择一种方法而不是另一种，答案是：这取决于！在许多情况下，选择不是线程_或_ async，而是线程_和_ async。

许多操作系统现在已经提供了基于线程的并发模型几十年了，许多编程语言因此支持它们。但是，这些模型并非没有它们的权衡。在许多操作系统上，它们为每个线程使用相当多的内存。线程也只有在你的操作系统和硬件支持它们时才是一个选项。与主流桌面和移动计算机不同，一些嵌入式系统根本没有操作系统，因此它们也没有线程。

async 模型提供了一套不同——并且最终互补——的权衡。在 async 模型中，并发操作不需要它们自己的线程。相反，它们可以在任务上运行，就像我们在流部分中使用 `trpl::spawn_task` 从同步函数启动工作一样。任务类似于线程，但不是由操作系统管理，而是由库级代码管理：运行时。

线程和任务生成的 API 如此相似是有原因的。线程充当同步操作集的边界；并发是_在线程之间_可能的。任务充当_异步_操作集的边界；并发在任务_之间_和_内部_都是可能的，因为任务可以在其主体中的 futures 之间切换。最后，futures 是 Rust 最细粒度的并发单元，每个 future 可能代表其他 futures 的树。运行时——特别是它的执行器——管理任务，任务管理 futures。在这方面，任务类似于轻量级、运行时管理的线程，具有由运行时而不是操作系统管理所带来的额外功能。

这并不意味着 async 任务总是比线程更好（反之亦然）。使用线程的并发在某些方面比使用 `async` 的并发更简单的编程模型。这可能是优势也可能是劣势。线程有点“发射后不管”；它们没有 future 的本地等价物，所以它们只是运行到完成，除了操作系统本身之外不会被中断。

事实证明，线程和任务经常很好地协同工作，因为任务可以（至少在某些运行时中）在线程之间移动。事实上，在底层，我们一直在使用的运行时——包括 `spawn_blocking` 和 `spawn_task` 函数——默认是多线程的！许多运行时使用称为_工作窃取_的方法，根据线程当前的使用情况，在线程之间透明地移动任务，以提高系统的整体性能。这种方法实际上需要线程_和_任务，因此需要 futures。

在考虑何时使用哪种方法时，请考虑这些经验法则：

- 如果工作_非常可并行化_（即 CPU 密集型），例如处理一堆可以单独处理的数据部分，线程是更好的选择。
- 如果工作_非常并发_（即 I/O 密集型），例如处理来自一堆不同来源的消息，这些消息可能以不同的间隔或不同的速率到达，async 是更好的选择。

如果你需要并行性和并发性，你不必在线程和 async 之间选择。你可以自由地一起使用它们，让每个都发挥其最擅长的部分。例如，代码清单17-25显示了在现实世界的 Rust 代码中这种混合的一个相当常见的例子。

<Listing number="17-25" caption="在线程中发送带有阻塞代码的消息，并在 async 块中等待消息" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-17-25/src/main.rs:all}}
```

</Listing>

我们首先创建一个 async channel，然后生成一个使用 `move` 关键字获取 channel 发送端所有权的线程。在线程内，我们发送数字1到10，在每条之间休眠一秒。最后，我们运行一个使用传递给 `trpl::block_on` 的 async 块创建的 future，就像我们在整个章节中一直做的那样。在该 future 中，我们等待这些消息，就像我们在其他消息传递示例中看到的那样。

回到我们在本章开头打开的场景，想象使用专用线程运行一组视频编码任务（因为视频编码是计算密集型的），但使用 async channel 通知 UI 这些操作已完成。在现实世界的用例中有无数这样的组合示例。

## 总结

这不是你在本书中最后一次看到并发。[第21章][ch21]<!-- ignore -->中的项目将在比这里讨论的更简单的示例更现实的情况下应用这些概念，并更直接地比较使用线程与任务和 futures 解决问题。

无论你选择这些方法中的哪一种，Rust 都为你提供了编写安全、快速、并发代码所需的工具——无论是用于高吞吐量 Web 服务器还是嵌入式操作系统。

接下来，我们将讨论随着 Rust 程序变大，如何以惯用的方式建模问题和构建解决方案。此外，我们将讨论 Rust 的惯用法与你可能从面向对象编程中熟悉的那些之间的关系。

[ch16]: http://localhost:3000/ch16-00-concurrency.html
[combining-futures]: ch17-03-more-futures.html#building-our-own-async-abstractions
[streams]: ch17-04-streams.html#composing-streams
[ch21]: ch21-00-final-project-a-web-server.html
