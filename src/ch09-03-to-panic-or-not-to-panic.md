## 是否 `panic!`

那么，你如何决定何时应该调用 `panic!` 以及何时应该返回 `Result`？当代码 panic 时，没有恢复的方法。你可以为任何错误情况调用 `panic!`，无论是否有可能的恢复方法，但这样你就是在代表调用代码做出情况不可恢复的决定。当你选择返回 `Result` 值时，你给调用代码选项。调用代码可以选择以适合其情况的方式尝试恢复，或者它可以决定在这种情况下 `Err` 值是不可恢复的，因此它可以调用 `panic!` 并将你的可恢复错误转换为不可恢复的错误。因此，当你定义可能失败的函数时，返回 `Result` 是一个很好的默认选择。

在示例、原型代码和测试等情况下，编写 panic 的代码而不是返回 `Result` 更合适。让我们探索原因，然后讨论编译器无法判断失败是不可能的但作为人类的你可以判断的情况。本章将以关于如何在库代码中决定是否 panic 的一些一般指导原则结束。

### 示例、原型代码和测试

当你编写示例来说明某个概念时，同时包含健壮的错误处理代码可能会使示例不太清楚。在示例中，理解对可能 panic 的方法（如 `unwrap`）的调用意味着作为你希望应用程序处理错误的方式的占位符，这可能基于代码的其余部分在做什么而有所不同。

类似地，`unwrap` 和 `expect` 方法在你进行原型设计并且还没有准备好决定如何处理错误时非常方便。它们在你的代码中留下清晰的标记，以便当你准备好使程序更健壮时使用。

如果测试中的方法调用失败，你希望整个测试失败，即使该方法不是正在测试的功能。因为 `panic!` 是测试被标记为失败的方式，调用 `unwrap` 或 `expect` 正是应该发生的事情。

<!-- Old headings. Do not remove or links may break. -->

<a id="cases-in-which-you-have-more-information-than-the-compiler"></a>

### 当你拥有比编译器更多信息时

当你有一些其他逻辑确保 `Result` 将具有 `Ok` 值，但编译器不理解该逻辑时，调用 `expect` 也是合适的。你仍然有一个需要处理的 `Result` 值：无论你正在调用的操作仍然有可能在一般情况下失败，即使在你的特定情况下这在逻辑上是不可能的。如果你可以通过手动检查代码来确保你永远不会有 `Err` 变体，那么调用 `expect` 并在参数文本中记录你认为你永远不会有 `Err` 变体的原因是完全可接受的。这是一个例子：

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

我们通过解析硬编码字符串来创建 `IpAddr` 实例。我们可以看到 `127.0.0.1` 是有效的 IP 地址，所以在这里使用 `expect` 是可以接受的。但是，拥有硬编码的有效字符串不会更改 `parse` 方法的返回类型：我们仍然得到 `Result` 值，编译器仍然会让我们处理 `Result`，就像 `Err` 变体是一种可能性一样，因为编译器不够聪明，无法看到这个字符串始终是有效的 IP 地址。如果 IP 地址字符串来自用户而不是硬编码到程序中，因此 _确实_ 有失败的可能性，我们肯定希望以更健壮的方式处理 `Result`。提及此 IP 地址是硬编码的假设将提示我们在将来需要从其他来源获取 IP 地址时，将 `expect` 更改为更好的错误处理代码。

### 错误处理指南

当你的代码可能最终处于不良状态时，建议让你的代码 panic。在这种情况下，_不良状态_ 是当某些假设、保证、契约或不变量被破坏时，例如当无效值、矛盾值或缺失值传递给你的代码时——加上以下一项或多项：

- 不良状态是意外的，而不是可能偶尔发生的事情，比如用户以错误的格式输入数据。
- 此点之后的代码需要依赖于不处于此不良状态，而不是在每一步都检查问题。
- 在你使用的类型中没有好的方法来编码此信息。我们将在第 18 章的["将状态和行为编码为类型"][encoding]<!-- ignore -->中通过一个示例来说明我们的意思。

如果有人调用你的代码并传入没有意义的值，如果你可以的话，最好返回错误，以便库的用户可以决定他们想在这种情况下做什么。但是，在继续可能不安全或有害的情况下，最好的选择可能是调用 `panic!` 并提醒使用你的库的人他们的代码中存在 bug，以便他们可以在开发过程中修复它。类似地，如果你正在调用你无法控制的外部代码并且返回你无法修复的无效状态，`panic!` 通常是合适的。

但是，当失败是预期的时，返回 `Result` 比进行 `panic!` 调用更合适。示例包括解析器被给予格式错误的数据或 HTTP 请求返回指示你已达到速率限制的状态。在这些情况下，返回 `Result` 表示失败是调用代码必须决定如何处理的预期可能性。

当你的代码执行的操作如果使用无效值调用可能会使用户处于危险之中时，你的代码应该首先验证值是有效的，如果值无效则 panic。这主要是出于安全原因：尝试对无效数据进行操作可能会使你的代码暴露于漏洞。这是标准库会在你尝试越界内存访问时调用 `panic!` 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全问题。函数通常有 _契约_：只有当输入满足特定要求时，才保证它们的行为。违反契约时 panic 是有意义的，因为契约违反总是表示调用方 bug，这不是你希望调用代码必须显式处理的一种错误。实际上，调用代码没有合理的恢复方法；调用 _程序员_ 需要修复代码。函数的契约，特别是当违反会导致 panic 时，应该在函数的 API 文档中解释。

但是，在所有函数中进行大量错误检查会很冗长和烦人。幸运的是，你可以使用 Rust 的类型系统（以及编译器完成的类型检查）为你执行许多检查。如果你的函数具有特定类型作为参数，你可以继续你的代码逻辑，知道编译器已经确保你有一个有效值。例如，如果你有一个类型而不是 `Option`，你的程序期望有 _某些东西_ 而不是 _什么都没有_。然后你的代码不必处理 `Some` 和 `None` 变体的两种情况：它只会有一个肯定有值的情况。试图将 nothing 传递给函数的代码甚至不会编译，所以你的函数不必在运行时检查该情况。另一个例子是使用无符号整数类型，如 `u32`，它确保参数永远不会是负数。

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-custom-types-for-validation"></a>

### 用于验证的自定义类型

让我们进一步探讨使用 Rust 的类型系统来确保我们有一个有效值的想法，并看看为验证创建自定义类型。回想第 2 章中的猜数字游戏，我们的代码要求用户猜测 1 到 100 之间的数字。我们在检查它与我们秘密数字之前从未验证用户的猜测是在这些数字之间；我们只验证猜测是正数。在这种情况下，后果不是非常严重：我们的"Too high"或"Too low"输出仍然正确。但是，引导用户进行有效猜测并在用户猜测超出范围的数字时（例如，当用户输入字母时）具有不同的行为将是一个有用的增强。

一种方法是解析猜测为 `i32` 而不是仅 `u32` 以允许潜在的负数，然后添加对数字在范围内的检查，如下所示：

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

</Listing>

`if` 表达式检查我们的值是否超出范围，告诉用户问题，并调用 `continue` 以开始循环的下一次迭代并请求另一个猜测。在 `if` 表达式之后，我们可以继续 `guess` 和秘密数字之间的比较，知道 `guess` 在 1 和 100 之间。

但是，这不是理想的解决方案：如果绝对关键的是程序只在 1 到 100 之间的值上操作，并且它有许多具有此要求的函数，在每个函数中进行这样的检查会很繁琐（并且可能影响性能）。

相反，我们可以在专用模块中创建新类型，并将验证放在创建类型实例的函数中，而不是到处重复验证。这样，函数在其签名中使用新类型是安全的，并且可以自信地使用它们接收的值。代码清单 9-13 显示了一种定义 `Guess` 类型的方法，只有当 `new` 函数接收到 1 到 100 之间的值时，才会创建 `Guess` 实例。

<Listing number="9-13" caption="一个 `Guess` 类型，只会在值在 1 到 100 之间时继续" file-name="src/guessing_game.rs">

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/guessing_game.rs}}
```

</Listing>

注意，*src/guessing_game.rs* 中的这段代码依赖于在 *src/lib.rs* 中添加模块声明 `mod guessing_game;`，我们在这里没有显示。在这个新模块的文件中，我们定义一个名为 `Guess` 的结构体，它有一个名为 `value` 的字段，保存一个 `i32`。这是数字将存储的地方。

然后，我们在 `Guess` 上实现一个名为 `new` 的关联函数，创建 `Guess` 值的实例。`new` 函数被定义为一个名为 `value` 的参数，类型为 `i32`，并返回 `Guess`。`new` 函数主体中的代码测试 `value` 以确保它在 1 到 100 之间。如果 `value` 没有通过此测试，我们进行 `panic!` 调用，这将提醒正在编写调用代码的程序员他们有一个需要修复的 bug，因为使用超出此范围的 `value` 创建 `Guess` 将违反 `Guess::new` 所依赖的契约。`Guess::new` 可能 panic 的条件应该在其面向公众的 API 文档中讨论；我们将在第 14 章中介绍你创建的 API 文档中指示 `panic!` 可能性的文档约定。如果 `value` 确实通过了测试，我们创建一个新的 `Guess`，其 `value` 字段设置为 `value` 参数并返回 `Guess`。

接下来，我们实现一个名为 `value` 的方法，它借用 `self`，没有任何其他参数，并返回 `i32`。这种类型的方法有时称为 _getter_，因为它的目的是从其字段中获取一些数据并返回它。这个公共方法是必要的，因为 `Guess` 结构体的 `value` 字段是私有的。`value` 字段是私有的很重要，这样使用 `Guess` 结构体的代码不允许直接设置 `value`：`guessing_game` 模块外部的代码 _必须_ 使用 `Guess::new` 函数创建 `Guess` 实例，从而确保没有方式让 `Guess` 具有未被 `Guess::new` 函数中的条件检查的 `value`。

具有参数或只返回 1 到 100 之间数字的函数然后可以在其签名中声明它接受或返回 `Guess` 而不是 `i32`，并且不需要在其主体中进行任何额外的检查。

## 总结

Rust 的错误处理功能旨在帮助你编写更健壮的代码。`panic!` 宏表示你的程序处于无法处理的状态，并让你告诉进程停止，而不是尝试使用无效或不正确的值继续。`Result` 枚举使用 Rust 的类型系统来指示操作可能以你的代码可以恢复的方式失败。你可以使用 `Result` 告诉调用你的代码的代码，它需要处理潜在的成功或失败。在适当的情况下使用 `panic!` 和 `Result` 将使你的代码在面对不可避免的问题时更加可靠。

现在你已经看到了标准库如何使用泛型与 `Option` 和 `Result` 枚举的有用方法，我们将讨论泛型如何工作以及如何在自己的代码中使用它们。

[encoding]: ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
